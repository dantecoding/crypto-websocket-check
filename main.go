package main

import (
	"github.com/graarh/golang-socketio"
	"github.com/graarh/golang-socketio/transport"
	"log"
	"strings"
	"strconv"
	"net/http"
	"fmt"
	"github.com/sirupsen/logrus"
	"github.com/rifflock/lfshook"
)

const DATA = 11

type AutoGenerated struct {
	Subs []string `json:"subs"`
}

type Message struct {
	Symbol string
	Price  float64
}

type helloHandler struct{}

var (
	Log       *logrus.Logger
)

func main() {
	subs := []string{"2~Binance~ADA~BTC"}
	l := NewLogger()

	st := &AutoGenerated{}
	st.Subs = subs

	c, err := gosocketio.Dial(
		gosocketio.GetUrl("streamer.cryptocompare.com", 443, true),
		transport.GetDefaultWebsocketTransport())
	if err != nil {
		log.Fatal(err)
	}

	defer c.Close()

	c.Emit("SubAdd", st)

	go c.On("m", func(h *gosocketio.Channel, args string) {
		code := strings.Split(args, "~")
		a, _ := strconv.Atoi(code[0])
		mess := &Message{}
		if a == DATA {
			s, _ := strconv.ParseFloat(code[2], 32)
			mess.Symbol = code[1]
			mess.Price = s
		}

		l.Info(code)
	})

	e := http.ListenAndServe(":9999", helloHandler{})
	log.Fatal(e)
}

func (h helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "hello, you've hit %s\n", r.URL.Path)
}

func NewLogger() *logrus.Logger {
	if Log != nil {
		return Log
	}

	pathMap := lfshook.PathMap{
		logrus.InfoLevel:  "info.log",
		logrus.ErrorLevel: "error.log",
	}

	Log = logrus.New()
	Log.Hooks.Add(lfshook.NewHook(
		pathMap,
		&logrus.TextFormatter{},
	))
	return Log
}
